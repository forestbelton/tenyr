#include "forth_common.th"

#define BINOP(Op)    \
    .word . + 1      \
    B   <- [PSP + 2] \
    C   <- [PSP + 1] \
    W   <-  B Op C   \
    PSP <-  PSP + 1  \
    W   -> [PSP + 1] \
    goto(NEXT)

// These comments were adapted from CamelForth
// http://www.bradrodriguez.com/papers/glosslo.txt
//
// NAME   stack in -- stack out          description
//
//   Guide to stack diagrams:  R: = return stack,
//   c = 8-bit character, flag = boolean (0 or -1),
//   n = signed 16-bit, u = unsigned 16-bit,
//   d = signed 32-bit, ud = unsigned 32-bit,
//   +n = unsigned 15-bit, x = any cell value,
//   i*x j*x = any number of cell values,
//   a-addr = aligned adrs, c-addr = character adrs
//   p-addr = I/O port adrs, sys = system-specific.
//   Refer to ANS Forth document for more details.
//
//                ANS Forth Core words
// These are required words whose definitions are
// specified by the ANS Forth document.
//
// !      x a-addr --           store cell in memory
// +      n1/u1 n2/u2 -- n3/u3             add n1+n2
// +!     n/u a-addr --           add cell to memory
// -      n1/u1 n2/u2 -- n3/u3        subtract n1-n2
head(SUB,-): BINOP(-)

// <      n1 n2 -- flag           test n1<n2, signed
head(CMP_LT,<):
    .word . + 1
    B   <- [PSP + 2]
    C   <- [PSP + 1]
    PSP <- PSP + 1
    E   <- B <= C
    G   <- B <> C
    E   <- E & G
    E   -> [PSP + 1]
    goto(NEXT)

// =      x1 x2 -- flag                   test x1=x2
head(CMP_EQ,=): BINOP(==)

// >      n1 n2 -- flag           test n1>n2, signed
head(CMP_GT,>): BINOP(>)

// >R     x --   R: -- x        push to return stack
head(PUSH_R,>R):
    .word . + 1
     W    <- [PSP + 1]
    [RSP] <-  W
     RSP  <-  RSP - 1
     PSP  <-  PSP + 1
    goto(NEXT)

// ?DUP   x -- 0 | x x                DUP if nonzero
// @      a-addr -- x         fetch cell from memory
head(AROBASE,@):
    .word . + 1
    W <- [PSP + 1]
    W <- [W]
    W -> [PSP + 1]
    goto(NEXT)

// 0<     n -- flag             true if TOS negative
// 0=     n/u -- flag           return true if TOS=0
// 1+     n1/u1 -- n2/u2                add 1 to TOS
head(ADD_1,1+):
    .word . + 1
    W <- [PSP + 1]
    W <- W + 1
    W -> [PSP + 1]
    goto(NEXT)

// 1-     n1/u1 -- n2/u2         subtract 1 from TOS
head(SUB_1,1-):
    .word . + 1
    W <- [PSP + 1]
    W <- W - 1
    W -> [PSP + 1]
    goto(NEXT)

// 2*     x1 -- x2             arithmetic left shift
head(MUL_2,2*):
    .word . + 1
    W <- [PSP + 1]
    W <- W << 1
    W -> [PSP + 1]
    goto(NEXT)

// 2/     x1 -- x2            arithmetic right shift
head(DIV_2,2/):
    .word . + 1
    W <- [PSP + 1]
    W <- W >> 1
    W -> [PSP + 1]
    goto(NEXT)

// AND    x1 x2 -- x3                    logical AND
head(AND,AND): BINOP(&)

// CONSTANT   n --           define a Forth constant
// C!     c c-addr --           store char in memory
// C@     c-addr -- c         fetch char from memory
// DROP   x --                     drop top of stack
head(DROP,DROP):
    .word . + 1
    PSP <- PSP + 1
    goto(NEXT)

// DUP    x -- x x            duplicate top of stack
head(DUP,DUP):
    .word . + 1
    W   <- [PSP + 1]
    W   -> [PSP]
    PSP <- PSP - 1
    goto(NEXT)

// EMIT   c --           output character to console
// EXECUTE   i*x xt -- j*x   execute Forth word 'xt'
// EXIT   --                 exit a colon definition
head(EXIT,EXIT):
    .word . + 1
    pop(RSP,IP)
    goto(NEXT)

// FILL   c-addr u c --        fill memory with char
// I      -- n   R: sys1 sys2 -- sys1 sys2
//                      get the innermost loop index
// INVERT x1 -- x2                 bitwise inversion
// J      -- n   R: 4*sys -- 4*sys
//                         get the second loop index
// KEY    -- c           get character from keyboard
// LSHIFT x1 u -- x2        logical L shift u places
// NEGATE x1 -- x2                  two's complement
// OR     x1 x2 -- x3                     logical OR
head(OR,OR): BINOP(|)

// OVER   x1 x2 -- x1 x2 x1        per stack diagram
// ROT    x1 x2 x3 -- x2 x3 x1     per stack diagram
// RSHIFT x1 u -- x2        logical R shift u places
// R>     -- x    R: x --      pop from return stack
head(POP_R,R>):
    .word . + 1
     W    <- [RSP + 1]
    [PSP] <-  W
     RSP  <-  RSP + 1
     PSP  <-  PSP - 1
    goto(NEXT)

// R@     -- x    R: x -- x       fetch from rtn stk
// SWAP   x1 x2 -- x2 x1          swap top two items
// UM*    u1 u2 -- ud       unsigned 16x16->32 mult.
// UM/MOD ud u1 -- u2 u3     unsigned 32/16->16 div.
// UNLOOP --   R: sys1 sys2 --       drop loop parms
// U<     u1 u2 -- flag         test u1<n2, unsigned
// VARIABLE   --             define a Forth variable
// XOR    x1 x2 -- x3                    logical XOR
head(XOR,XOR): BINOP(^)

//
//                ANS Forth Extensions
// These are optional words whose definitions are
// specified by the ANS Forth document.
//
// <>     x1 x2 -- flag               test not equal
head(CMP_NE,<>): BINOP(<>)

// BYE    i*x --                      return to CP/M
head(BYE,BYE):
    .word . + 1
    PSP <- [reloc(_PSPinit)]
    RSP <- [reloc(_RSPinit)]
    illegal

// CMOVE  c-addr1 c-addr2 u --      move from bottom
// CMOVE> c-addr1 c-addr2 u --         move from top
// KEY?   -- flag        return true if char waiting
// M+     d1 n -- d2            add single to double
// NIP    x1 x2 -- x2              per stack diagram
// TUCK   x1 x2 -- x2 x1 x2        per stack diagram
// U>     u1 u2 -- flag         test u1>u2, unsigned

head(NOOP,NOOP):
    .word @ENTER
    .word @EXIT

